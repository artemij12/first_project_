unsigned int count_of_rotation = 0;//количество прерываний оптопары
float time_of_rotation = 0;//время прерывания оптопары
setup()
{
pinMode(2,INPUT);//установка ножки камня на чтение сигналов из оптопары
enum rezhim
{
ust, work,reset
};
rezhim R=work //перечисляемый тип устанавливаем в работу 
}
short pusk_push()// в эту функцию можно передать значение счетчика (для разных камней разная выдержка будет short pusk_push(short t), но пока смысла нет,камень один 
{
//Если клавиша нажата долго возвращем например 1 , т.е. счетчик досчитал до конца 
//если нажата не долго 2
// считываем уровня сигнала на пине, если низкий сразу возвращаем 0
}
bool push_set()
{
//считываем уровня сигнала на пине, если низкий сразу возвращаем False , иначе True
//При нажатии меняем переменную R на другую перчисляемую
}
void print_char(short c)// функция печати пункта меню
{
// Взависимости от значения с выводим на экран U/W/R(резет потом скидываем и вовращаемся в режим W)
}
void print_cyf(short i,bool above)
{
//Функция вывода на экран цифр, если adove==True выводим i переведя его в строку, если false выводим 00.00 (это когда резет) 
}
void start_inr() //устанавливаем прерывание , данные берем из setup.h
{
}
void stop_inr() // убираем прерывание....Можно конечно и в цикле loop все это написать, но функциями сподручнее
{
}
void count_and_time_rot(){
//в этой функции будет реализован подсчет количества оборотов крыльчатки и времени, на которое прерывается оптопара
}
loop ()
{
//здесь реализуем бесконечный цикл обработки нажатий клавиш
// тут будет простая лесенка операторов выбора вида if push_set() { ....} else
// или в принципе switch...case... еще удобно делать бесконечные циклы типа while True с выходом по break; Ни кто не мешает комбинировать
// так же напомню, что в Си 0 это False, любое отрицательное число False , также очень удобны конструкции типа if push_pusk()&&R==work {...}
// тут логическое И применяется к двум результатам возвращаемого значения функции pusk_push() и результат сравнения переменной R с перечисляемым типом
}
bool f_reset(u_int t) // функция зажима клавиши Пуск/Стоп
{
// здесь реализован счетчик, ну или если захочется очень))) установка и обработка прерывания, если нужное время прошло клавиша зажата return True
}
short speed_calc()//она должна уже возвращать количество литров
{
//эта функция вызывается по прерыванию, когда тикнул таймер, она высчитывает на основании глобальных пременных объявленных в setup() количество вращений крыльчатки и затем
// она берет данные юстировки, где известно, что определенное количество оборотов крыльчатки соответсвует определенному количеству жидкости прошедшей через трубу
//таких функций можно наделать много и матаппарат еще придется допиливать напильником, но он простой....и чем больше таких функций, тем точнее будет матмодель  
//пока надо сделать грубую модель, а вот ее улучшать как мне видится можно математикой
}
void math_model(....)// это штука на будущее...отдельно от обработчиков надо создать матмодель, в которую мы передаем данные (скорей всего в структурах struct) и она уже считает все как надо
void save_rez(short ob, short kolvj, short koeff)
{
создаем условную табличку в EEPROM...Упакованную ...2 байта на каждую переменную...Читать легко, записывать еще проще..
}
// Это пока в общих чертах на сутках накидал на листочке(так лучше думается )))) и перебил в цифру...Это еще просто наработка....Вообще если под один камень писать, тут есть где разгуляться ассму...
//Но лучше Си....масштабируемость даже близко не сравнима

